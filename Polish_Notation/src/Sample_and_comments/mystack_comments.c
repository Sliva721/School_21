// Кратко о работе кода:

// 1. Структура стека: Стек реализуется через структуру `st`, которая содержит символ и указатель на следующий узел.
// 2. Функции стека: Реализованы функции `push` для добавления элементов и `delete` для их удаления.
// 3. Приоритет операторов: Функция `priority` определяет приоритет различных операторов, что может быть полезно в контексте анализа выражений в польской нотации.


#include "mystack.h" // Подключаем заголовочный файл, который должен содержать определение структуры стека.

#include <stdio.h>  // Подключаем стандартную библиотеку для ввода-вывода.
#include <stdlib.h> // Подключаем стандартную библиотеку для управления памятью.

struct st {           // Определяем структуру для узла стека.
    char c;          // Храним символ (значение).
    struct st *next; // Указатель на следующий узел в стеке.
};

// Функция для удаления верхнего элемента стека и возвращения его значения.
char delete(struct st **HEAD) {
    struct st *upper; // Указатель на удаляемый узел.
    char symbol;      // Переменная для хранения значения символа.

    // Проверка: если стек пуст, возвращаем null-символ.
    if (*HEAD == NULL) return '\0';

    upper = *HEAD;        // Сохраняем верхний элемент стека.
    symbol = upper->c;    // Получаем символ из верхнего элемента.
    *HEAD = upper->next;  // Сдвигаем указатель на верхний элемент на следующий узел.
    free(upper);          // Освобождаем память, занятую верхним элементом.
    return symbol;        // Возвращаем символ.
}

// Функция для добавления нового элемента в стек.
struct st *push(struct st *HEAD, char symbol) {
    struct st *upper; // Указатель на новый узел.

    // Выделяем память для нового узла.
    if ((upper = malloc(sizeof(struct st))) == NULL) {
        puts("no memory"); // Если память не выделена, выводим сообщение об ошибке.
        exit(-1);         // Завершаем программу с ошибкой.
    }

    upper->c = symbol;   // Записываем символ в новый узел.
    upper->next = HEAD;  // Указываем, что следующий элемент – текущий верхний элемент стека.
    return upper;        // Возвращаем указатель на новый верхний элемент.
}

// Функция для определения приоритета операторов.
int priority(char symbol) {
    switch (symbol) {     // Используем оператор switch для определения приоритета.
        case 'c':
        case 's':
        case 't':
        case 'g':
        case 'q':
        case 'l':
            return 4;    // Высокий приоритет для данных операторов.
        case '*':
        case '/':
            return 3;    // Средний приоритет.

        case '-':
        case '+':
            return 2;    // Низкий приоритет для этих операторов.

        case '(':
            return 1;    // Приоритет для открывающей скобки.
    }
    return 0; // Если символ не оператор, возвращаем 0.
}