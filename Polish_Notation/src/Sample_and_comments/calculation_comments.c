//Данный код реализует калькулятор, который использует польскую нотацию для выполнения арифметических операций и вычисления значений функций. 
// Основные компоненты кода следующие:

// 1. Функция `counter`:
//    - Эта функция принимает строку `output_str`, которая представляет выражение в обратной польской нотации, указатель на стек `head` и значение `x`.
//    - Она перебирает символы строки и, в зависимости от символа, выполняет соответствующие действия: 
//      - Если символ - 'x', то значение `x` помещается в стек.
//      - Если символ - цифра (от '0' до '9'), она преобразуется в число и также помещается в стек.
//      - Для операторов (`+`, `-`, `*`, `/`, `^`) два значения извлекаются из стека, выполняется операция, и результат помещается обратно в стек.
//      - Для тригонометрических функций (`s`, `c`, `t`, `g`) и других математических функций (`q` для квадратного корня, `l` для логарифма) происходит аналогичное извлечение значения, применение функции и помещение результата в стек.
//    - Функция возвращает конечный результат, извлекая последний элемент из стека.

// 2. Функция `init`:
//    - Эта функция инициализирует стек, устанавливая его указатель на `NULL`.

// 3. Функция `pushing`:
//    - Функция добавляет новое значение в стек. Она выделяет память для нового элемента (на основе структуры `OPERATIONS`), помещает это значение на вершину стека и обновляет указатель.

// 4. Функция `pop`:
//    - Эта функция извлекает значение с вершины стека, обновляет указатель стека и освобождает память для удаляемого элемента.

// 5. Функция `add_func_for_graph`:
//    - Функция создает графическое представление функции, на основе высоты и ширины массива `graph`. Для каждого элемента графика вычисляется соответствующее значение функции с использованием функции `counter` и затем заполняется массив `graph` символами (например, `STAR`), основываясь на вычисленных значениях.

// Код использует стек для выполнения операций в обратной польской нотации, что позволяет обрабатывать выражения корректно, без необходимости следить за приоритетом операций.



#include "calculation.h"  // Подключение пользовательского заголовочного файла для определения структуры и функций

#include <math.h>        // Подключение библиотеки для математических функций
#include <stdlib.h>     // Подключение библиотеки для стандартных функций, включая динамическое выделение памяти
#include <string.h>     // Подключение библиотеки для работы со строками

#include "draw.h"       // Подключение пользовательского заголовочного файла для рисования графиков

// Функция counter принимает строку output_str, указатель на HEAD и значение x, и вычисляет результат
double counter(char *output_str, HEAD *head, double x) {
    int n = strlen(output_str); // Получаем длину строки output_str
    double num1, num2;          // Переменные для хранения чисел из стека

    for (int i = 0; i < n; ++i) { // Перебираем каждый символ в строке
        if (output_str[i] == 'x') {
            pushing(x, head); // Если символ 'x', помещаем значение x в стек
        } else if (output_str[i] >= '0' && output_str[i] <= '9') {
            pushing((output_str[i] - '0'), head); // Конвертируем символ цифры в число и помещаем в стек
        } else if (output_str[i] == '+') { // Обработка операции сложения
            num2 = pop(head); // Извлекаем два верхних значения из стека
            num1 = pop(head);
            pushing(num1 + num2, head); // Суммируем и помещаем результат обратно в стек
        } else if (output_str[i] == '-') { // Обработка операции вычитания
            num2 = pop(head);
            num1 = pop(head);
            pushing(num1 - num2, head);
        } else if (output_str[i] == '*') { // Обработка операции умножения
            num2 = pop(head);
            num1 = pop(head);
            pushing(num1 * num2, head);
        } else if (output_str[i] == '/') { // Обработка операции деления
            num2 = pop(head);
            num1 = pop(head);
            if (num2 != 0) // Проверяем деление на ноль
                pushing(num1 / num2, head);
            else
                pushing(1000, head); // Если деление на ноль, помещаем заменительное значение
        } else if (output_str[i] == '^') { // Обработка операции возведения в степень
            num2 = pop(head);
            num1 = pop(head);
            pushing(pow(num1, num2), head); // Используем функцию pow для возведения в степень
        } else if (output_str[i] == 's') { // Синус
            num1 = pop(head);
            pushing(sin(num1), head);
        } else if (output_str[i] == 'c') { // Косинус
            num1 = pop(head);
            pushing(cos(num1), head);
        } else if (output_str[i] == 't') { // Тангенс
            num1 = pop(head);
            pushing(tan(num1), head);
        } else if (output_str[i] == 'g') { // Котангенс
            num1 = pop(head);
            pushing(1 / tan(num1), head);
        } else if (output_str[i] == 'q') { // Квадратный корень
            num1 = pop(head);
            pushing(sqrt(num1), head);
        } else if (output_str[i] == 'l') { // Логарифм
            num1 = pop(head);
            pushing(log(num1), head);
        }
    }
    return pop(head); // Возвращаем конечное значение, извлеченное из стека
}

// Функция инициализации стека
void init(HEAD *head) { head->point = NULL; }

// Функция для добавления элемента в стек
void pushing(double sym, HEAD *head) {
    OPERATIONS *tmp; // Временный указатель на текущую вершину стека
    tmp = head->point; // Сохраняем предыдущую вершину
    OPERATIONS *new = (OPERATIONS *)malloc(sizeof(OPERATIONS)); // Выделяем память для нового элемента стека
    new->oper = sym; // Устанавливаем значение
    new->point = tmp; // Устанавливаем указатель на предыдущую вершину
    head->point = new; // Обновляем вершину стека
}

// Функция для извлечения элемента из стека
double pop(HEAD *head) {
    double x;
    OPERATIONS *tmp = head->point; // Сохраняем текущую вершину
    x = head->point->oper; // Получаем значение из вершины
    head->point = head->point->point; // Обновляем вершину стека
    free(tmp); // Освобождаем память
    return x; // Возвращаем извлеченное значение
}

// Функция для добавления графика в 2D-матрицу
void add_func_for_graph(char **graph, int height, int width, char *out, HEAD *head) {
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) { // Проходим по каждому элементу матрицы
            int y = 25; // Начальное значение для y
            if (x != 0) 
                y = round(12 + 12 * counter(out, head, (acos(-1) * x) / 20)); // Вычисление значения функции
            if (y > 0 && y < 25) 
                graph[y][x] = STAR; // Помещаем символ в соответствующую ячейку графика
        }
    }
}